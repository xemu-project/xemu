#!/usr/bin/env python3
# group: rw
#
# Test cases for the QMP 'blockdev-reopen' command
#
# Copyright (C) 2018-2019 Igalia, S.L.
# Author: Alberto Garcia <berto@igalia.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import copy
import json
import os
import re
from subprocess import CalledProcessError

import iotests
from iotests import qemu_img, qemu_io

hd_path = [
    os.path.join(iotests.test_dir, 'hd0.img'),
    os.path.join(iotests.test_dir, 'hd1.img'),
    os.path.join(iotests.test_dir, 'hd2.img')
]

def hd_opts(idx):
    return {'driver': iotests.imgfmt,
            'node-name': 'hd%d' % idx,
            'file': {'driver': 'file',
                     'node-name': 'hd%d-file' % idx,
                     'filename':  hd_path[idx] } }

class TestBlockdevReopen(iotests.QMPTestCase):
    total_io_cmds = 0

    def setUp(self):
        qemu_img('create', '-f', iotests.imgfmt, hd_path[0], '3M')
        qemu_img('create', '-f', iotests.imgfmt, '-b', hd_path[0],
                 '-F', iotests.imgfmt, hd_path[1])
        qemu_img('create', '-f', iotests.imgfmt, hd_path[2], '3M')
        qemu_io('-f', iotests.imgfmt, '-c', 'write -P 0xa0  0 1M', hd_path[0])
        qemu_io('-f', iotests.imgfmt, '-c', 'write -P 0xa1 1M 1M', hd_path[1])
        qemu_io('-f', iotests.imgfmt, '-c', 'write -P 0xa2 2M 1M', hd_path[2])
        self.vm = iotests.VM()
        self.vm.launch()

    def tearDown(self):
        self.vm.shutdown()
        self.check_qemu_io_errors()
        os.remove(hd_path[0])
        os.remove(hd_path[1])
        os.remove(hd_path[2])

    # The output of qemu-io is not returned by vm.hmp_qemu_io() but
    # it's stored in the log and can only be read when the VM has been
    # shut down. This function runs qemu-io and keeps track of the
    # number of times it's been called.
    def run_qemu_io(self, img, cmd):
        result = self.vm.hmp_qemu_io(img, cmd)
        self.assert_qmp(result, 'return', '')
        self.total_io_cmds += 1

    # Once the VM is shut down we can parse the log and see if qemu-io
    # ran without errors.
    def check_qemu_io_errors(self):
        self.assertFalse(self.vm.is_running())
        found = 0
        log = self.vm.get_log()
        for line in log.split("\n"):
            if line.startswith("Pattern verification failed"):
                raise Exception("%s (command #%d)" % (line, found))
            if re.match("(read|wrote) .*/.* bytes at offset", line):
                found += 1
        self.assertEqual(found, self.total_io_cmds,
                         "Expected output of %d qemu-io commands, found %d" %
                         (found, self.total_io_cmds))

    # Run blockdev-reopen on a list of block devices
    def reopenMultiple(self, opts, errmsg = None):
        result = self.vm.qmp('blockdev-reopen', conv_keys=False, options=opts)
        if errmsg:
            self.assert_qmp(result, 'error/class', 'GenericError')
            self.assert_qmp(result, 'error/desc', errmsg)
        else:
            self.assert_qmp(result, 'return', {})

    # Run blockdev-reopen on a single block device (specified by
    # 'opts') but applying 'newopts' on top of it. The original 'opts'
    # dict is unmodified
    def reopen(self, opts, newopts = {}, errmsg = None):
        opts = copy.deepcopy(opts)

        # Apply the changes from 'newopts' on top of 'opts'
        for key in newopts:
            value = newopts[key]
            # If key has the form "foo.bar" then we need to do
            # opts["foo"]["bar"] = value, not opts["foo.bar"] = value
            subdict = opts
            while key.find('.') != -1:
                [prefix, key] = key.split('.', 1)
                subdict = opts[prefix]
            subdict[key] = value

        self.reopenMultiple([ opts ], errmsg)


    # Run query-named-block-nodes and return the specified entry
    def get_node(self, node_name):
        result = self.vm.qmp('query-named-block-nodes')
        for node in result['return']:
            if node['node-name'] == node_name:
                return node
        return None

    # Run 'query-named-block-nodes' and compare its output with the
    # value passed by the user in 'graph'
    def check_node_graph(self, graph):
        result = self.vm.qmp('query-named-block-nodes')
        self.assertEqual(json.dumps(graph,  sort_keys=True),
                         json.dumps(result, sort_keys=True))

    # This test opens one single disk image (without backing files)
    # and tries to reopen it with illegal / incorrect parameters.
    def test_incorrect_parameters_single_file(self):
        # Open 'hd0' only (no backing files)
        opts = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})
        original_graph = self.vm.qmp('query-named-block-nodes')

        # We can reopen the image passing the same options
        self.reopen(opts)

        # We can also reopen passing a child reference in 'file'
        self.reopen(opts, {'file': 'hd0-file'})

        # We cannot change any of these
        self.reopen(opts, {'node-name': 'not-found'}, "Failed to find node with node-name='not-found'")
        self.reopen(opts, {'node-name': ''}, "Failed to find node with node-name=''")
        self.reopen(opts, {'node-name': None}, "Invalid parameter type for 'options[0].node-name', expected: string")
        self.reopen(opts, {'driver': 'raw'}, "Cannot change the option 'driver'")
        self.reopen(opts, {'driver': ''}, "Parameter 'driver' does not accept value ''")
        self.reopen(opts, {'driver': None}, "Invalid parameter type for 'options[0].driver', expected: string")
        self.reopen(opts, {'file': 'not-found'}, "Cannot find device='' nor node-name='not-found'")
        self.reopen(opts, {'file': ''}, "Cannot find device='' nor node-name=''")
        self.reopen(opts, {'file': None}, "Invalid parameter type for 'file', expected: BlockdevRef")
        self.reopen(opts, {'file.node-name': 'newname'}, "Cannot change the option 'node-name'")
        self.reopen(opts, {'file.driver': 'host_device'}, "Cannot change the option 'driver'")
        self.reopen(opts, {'file.filename': hd_path[1]}, "Cannot change the option 'filename'")
        self.reopen(opts, {'file.aio': 'native'}, "Cannot change the option 'aio'")
        self.reopen(opts, {'file.locking': 'off'}, "Cannot change the option 'locking'")
        self.reopen(opts, {'file.filename': None}, "Invalid parameter type for 'options[0].file.filename', expected: string")

        # node-name is optional in BlockdevOptions, but blockdev-reopen needs it
        del opts['node-name']
        self.reopen(opts, {}, "node-name not specified")

        # Check that nothing has changed
        self.check_node_graph(original_graph)

        # Remove the node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # This test opens an image with a backing file and tries to reopen
    # it with illegal / incorrect parameters.
    def test_incorrect_parameters_backing_file(self):
        # Open hd1 omitting the backing options (hd0 will be opened
        # with the default options)
        opts = hd_opts(1)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})
        original_graph = self.vm.qmp('query-named-block-nodes')

        # We can't reopen the image passing the same options, 'backing' is mandatory
        self.reopen(opts, {}, "backing is missing for 'hd1'")

        # Everything works if we pass 'backing' using the existing node name
        for node in original_graph['return']:
            if node['drv'] == iotests.imgfmt and node['file'] == hd_path[0]:
                backing_node_name = node['node-name']
        self.reopen(opts, {'backing': backing_node_name})

        # We can't use a non-existing or empty (non-NULL) node as the backing image
        self.reopen(opts, {'backing': 'not-found'}, "Cannot find device=\'\' nor node-name=\'not-found\'")
        self.reopen(opts, {'backing': ''}, "Cannot find device=\'\' nor node-name=\'\'")

        # We can reopen the image just fine if we specify the backing options
        opts['backing'] = {'driver': iotests.imgfmt,
                           'file': {'driver': 'file',
                                    'filename': hd_path[0]}}
        self.reopen(opts)

        # We cannot change any of these options
        self.reopen(opts, {'backing.node-name': 'newname'}, "Cannot change the option 'node-name'")
        self.reopen(opts, {'backing.driver': 'raw'}, "Cannot change the option 'driver'")
        self.reopen(opts, {'backing.file.node-name': 'newname'}, "Cannot change the option 'node-name'")
        self.reopen(opts, {'backing.file.driver': 'host_device'}, "Cannot change the option 'driver'")

        # Check that nothing has changed since the beginning
        self.check_node_graph(original_graph)

        # Remove the node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd1')
        self.assert_qmp(result, 'return', {})

    # Reopen an image several times changing some of its options
    def test_reopen(self):
        try:
            qemu_io('-f', 'raw', '-t', 'none', '-c', 'quit', hd_path[0])
            supports_direct = True
        except CalledProcessError as exc:
            if 'O_DIRECT' in exc.stdout:
                supports_direct = False
            else:
                raise

        # Open the hd1 image passing all backing options
        opts = hd_opts(1)
        opts['backing'] = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})
        original_graph = self.vm.qmp('query-named-block-nodes')

        # We can reopen the image passing the same options
        self.reopen(opts)

        # Reopen in read-only mode
        self.assert_qmp(self.get_node('hd1'), 'ro', False)

        self.reopen(opts, {'read-only': True})
        self.assert_qmp(self.get_node('hd1'), 'ro', True)
        self.reopen(opts)
        self.assert_qmp(self.get_node('hd1'), 'ro', False)

        # Change the cache options
        self.assert_qmp(self.get_node('hd1'), 'cache/writeback', True)
        self.assert_qmp(self.get_node('hd1'), 'cache/direct', False)
        self.assert_qmp(self.get_node('hd1'), 'cache/no-flush', False)
        self.reopen(opts, {'cache': { 'direct': supports_direct, 'no-flush': True }})
        self.assert_qmp(self.get_node('hd1'), 'cache/writeback', True)
        self.assert_qmp(self.get_node('hd1'), 'cache/direct', supports_direct)
        self.assert_qmp(self.get_node('hd1'), 'cache/no-flush', True)

        # Reopen again with the original options
        self.reopen(opts)
        self.assert_qmp(self.get_node('hd1'), 'cache/writeback', True)
        self.assert_qmp(self.get_node('hd1'), 'cache/direct', False)
        self.assert_qmp(self.get_node('hd1'), 'cache/no-flush', False)

        # Change 'detect-zeroes' and 'discard'
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'off')
        self.reopen(opts, {'detect-zeroes': 'on'})
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'on')
        self.reopen(opts, {'detect-zeroes': 'unmap'},
                    "setting detect-zeroes to unmap is not allowed " +
                    "without setting discard operation to unmap")
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'on')
        self.reopen(opts, {'detect-zeroes': 'unmap', 'discard': 'unmap'})
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'unmap')
        self.reopen(opts)
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'off')

        # Changing 'force-share' is currently not supported
        self.reopen(opts, {'force-share': True}, "Cannot change the option 'force-share'")

        # Change some qcow2-specific options
        # No way to test for success other than checking the return message
        if iotests.imgfmt == 'qcow2':
            self.reopen(opts, {'l2-cache-entry-size': 128 * 1024},
                        "L2 cache entry size must be a power of two "+
                        "between 512 and the cluster size (65536)")
            self.reopen(opts, {'l2-cache-size': 1024 * 1024,
                               'cache-size':     512 * 1024},
                        "l2-cache-size may not exceed cache-size")
            self.reopen(opts, {'l2-cache-size':        4 * 1024 * 1024,
                               'refcount-cache-size':  4 * 1024 * 1024,
                               'l2-cache-entry-size': 32 * 1024})
            self.reopen(opts, {'pass-discard-request': True})

        # Check that nothing has changed since the beginning
        # (from the parameters that we can check)
        self.check_node_graph(original_graph)

        # Check that the node names (other than the top-level one) are optional
        del opts['file']['node-name']
        del opts['backing']['node-name']
        del opts['backing']['file']['node-name']
        self.reopen(opts)
        self.check_node_graph(original_graph)

        # Reopen setting backing = null, this removes the backing image from the chain
        self.reopen(opts, {'backing': None})
        self.assert_qmp_absent(self.get_node('hd1'), 'image/backing-image')

        # Open the 'hd0' image
        result = self.vm.qmp('blockdev-add', conv_keys = False, **hd_opts(0))
        self.assert_qmp(result, 'return', {})

        # Reopen the hd1 image setting 'hd0' as its backing image
        self.reopen(opts, {'backing': 'hd0'})
        self.assert_qmp(self.get_node('hd1'), 'image/backing-image/filename', hd_path[0])

        # Check that nothing has changed since the beginning
        self.reopen(hd_opts(0), {'read-only': True})
        self.check_node_graph(original_graph)

        # The backing file (hd0) is now a reference, we cannot change backing.* anymore
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # We can't remove 'hd0' while it's a backing image of 'hd1'
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "Node 'hd0' is busy: node is used as backing hd of 'hd1'")

        # But we can remove both nodes if done in the proper order
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd1')
        self.assert_qmp(result, 'return', {})
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # Reopen a raw image and see the effect of changing the 'offset' option
    def test_reopen_raw(self):
        opts = {'driver': 'raw', 'node-name': 'hd0',
                'file': { 'driver': 'file',
                          'filename': hd_path[0],
                          'node-name': 'hd0-file' } }

        # First we create a 2MB raw file, and fill each half with a
        # different value
        qemu_img('create', '-f', 'raw', hd_path[0], '2M')
        qemu_io('-f', 'raw', '-c', 'write -P 0xa0  0 1M', hd_path[0])
        qemu_io('-f', 'raw', '-c', 'write -P 0xa1 1M 1M', hd_path[0])

        # Open the raw file with QEMU
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Read 1MB from offset 0
        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")

        # Reopen the image with a 1MB offset.
        # Now the results are different
        self.reopen(opts, {'offset': 1024*1024})
        self.run_qemu_io("hd0", "read -P 0xa1  0 1M")

        # Reopen again with the original options.
        # We get the original results again
        self.reopen(opts)
        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")

        # Remove the block device
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # Omitting an option should reset it to the default value, but if
    # an option cannot be changed it shouldn't be possible to reset it
    # to its default value either
    def test_reset_default_values(self):
        opts = {'driver': 'qcow2', 'node-name': 'hd0',
                'file': { 'driver': 'file',
                          'filename': hd_path[0],
                          'x-check-cache-dropped': True, # This one can be changed
                          'locking': 'off',              # This one can NOT be changed
                          'node-name': 'hd0-file' } }

        # Open the file with QEMU
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # file.x-check-cache-dropped can be changed...
        self.reopen(opts, { 'file.x-check-cache-dropped': False })
        # ...and dropped completely (resetting to the default value)
        del opts['file']['x-check-cache-dropped']
        self.reopen(opts)

        # file.locking cannot be changed nor reset to the default value
        self.reopen(opts, { 'file.locking': 'on' }, "Cannot change the option 'locking'")
        del opts['file']['locking']
        self.reopen(opts, {}, "Option 'locking' cannot be reset to its default value")
        # But we can reopen it if we maintain its previous value
        self.reopen(opts, { 'file.locking': 'off' })

        # Remove the block device
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # This test modifies the node graph a few times by changing the
    # 'backing' option on reopen and verifies that the guest data that
    # is read afterwards is consistent with the graph changes.
    def test_io_with_graph_changes(self):
        opts = []

        # Open hd0, hd1 and hd2 without any backing image
        for i in range(3):
            opts.append(hd_opts(i))
            opts[i]['backing'] = None
            result = self.vm.qmp('blockdev-add', conv_keys = False, **opts[i])
            self.assert_qmp(result, 'return', {})

        # hd0
        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0    1M 1M")
        self.run_qemu_io("hd0", "read -P 0    2M 1M")

        # hd1 <- hd0
        self.reopen(opts[0], {'backing': 'hd1'})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd0", "read -P 0    2M 1M")

        # hd1 <- hd0 , hd1 <- hd2
        self.reopen(opts[2], {'backing': 'hd1'})

        self.run_qemu_io("hd2", "read -P 0     0 1M")
        self.run_qemu_io("hd2", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd2", "read -P 0xa2 2M 1M")

        # hd1 <- hd2 <- hd0
        self.reopen(opts[0], {'backing': 'hd2'})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd0", "read -P 0xa2 2M 1M")

        # hd2 <- hd0
        self.reopen(opts[2], {'backing': None})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0    1M 1M")
        self.run_qemu_io("hd0", "read -P 0xa2 2M 1M")

        # hd2 <- hd1 <- hd0
        self.reopen(opts[1], {'backing': 'hd2'})
        self.reopen(opts[0], {'backing': 'hd1'})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd0", "read -P 0xa2 2M 1M")

        # Illegal operation: hd2 is a child of hd1
        self.reopen(opts[2], {'backing': 'hd1'},
                    "Making 'hd1' a backing child of 'hd2' would create a cycle")

        # hd2 <- hd0, hd2 <- hd1
        self.reopen(opts[0], {'backing': 'hd2'})

        self.run_qemu_io("hd1", "read -P 0     0 1M")
        self.run_qemu_io("hd1", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd1", "read -P 0xa2 2M 1M")

        # More illegal operations
        self.reopen(opts[2], {'backing': 'hd1'},
                    "Making 'hd1' a backing child of 'hd2' would create a cycle")
        self.reopen(opts[2], {'file': 'hd0-file'},
                    "Permission conflict on node 'hd0-file': permissions 'write, resize' are both required by node 'hd0' (uses node 'hd0-file' as 'file' child) and unshared by node 'hd2' (uses node 'hd0-file' as 'file' child).")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd2')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "Node 'hd2' is busy: node is used as backing hd of 'hd0'")

        # hd1 doesn't have a backing file now
        self.reopen(opts[1], {'backing': None})

        self.run_qemu_io("hd1", "read -P 0     0 1M")
        self.run_qemu_io("hd1", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd1", "read -P 0    2M 1M")

        # We can't remove the 'backing' option if the image has a
        # default backing file
        del opts[1]['backing']
        self.reopen(opts[1], {}, "backing is missing for 'hd1'")

        self.run_qemu_io("hd1", "read -P 0     0 1M")
        self.run_qemu_io("hd1", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd1", "read -P 0    2M 1M")

    # This test verifies that we can't change the children of a block
    # device during a reopen operation in a way that would create
    # cycles in the node graph
    @iotests.skip_if_unsupported(['blkverify'])
    def test_graph_cycles(self):
        opts = []

        # Open all three images without backing file
        for i in range(3):
            opts.append(hd_opts(i))
            opts[i]['backing'] = None
            result = self.vm.qmp('blockdev-add', conv_keys = False, **opts[i])
            self.assert_qmp(result, 'return', {})

        # hd1 <- hd0, hd1 <- hd2
        self.reopen(opts[0], {'backing': 'hd1'})
        self.reopen(opts[2], {'backing': 'hd1'})

        # Illegal: hd2 is backed by hd1
        self.reopen(opts[1], {'backing': 'hd2'},
                    "Making 'hd2' a backing child of 'hd1' would create a cycle")

        # hd1 <- hd0 <- hd2
        self.reopen(opts[2], {'backing': 'hd0'})

        # Illegal: hd2 is backed by hd0, which is backed by hd1
        self.reopen(opts[1], {'backing': 'hd2'},
                    "Making 'hd2' a backing child of 'hd1' would create a cycle")

        # Illegal: hd1 cannot point to itself
        self.reopen(opts[1], {'backing': 'hd1'},
                    "Making 'hd1' a backing child of 'hd1' would create a cycle")

        # Remove all backing files
        self.reopen(opts[0])
        self.reopen(opts[2])

        ##########################################
        # Add a blkverify node using hd0 and hd1 #
        ##########################################
        bvopts = {'driver': 'blkverify',
                  'node-name': 'bv',
                  'test': 'hd0',
                  'raw': 'hd1'}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **bvopts)
        self.assert_qmp(result, 'return', {})

        # blkverify doesn't currently allow reopening. TODO: implement this
        self.reopen(bvopts, {}, "Block format 'blkverify' used by node 'bv'" +
                    " does not support reopening files")

        # Illegal: hd0 is a child of the blkverify node
        self.reopen(opts[0], {'backing': 'bv'},
                    "Making 'bv' a backing child of 'hd0' would create a cycle")

        # Delete the blkverify node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'bv')
        self.assert_qmp(result, 'return', {})

    # Replace the protocol layer ('file' parameter) of a disk image
    def test_replace_file(self):
        # Create two small raw images and add them to a running VM
        qemu_img('create', '-f', 'raw', hd_path[0], '10k')
        qemu_img('create', '-f', 'raw', hd_path[1], '10k')

        hd0_opts = {'driver': 'file', 'node-name': 'hd0-file', 'filename':  hd_path[0] }
        hd1_opts = {'driver': 'file', 'node-name': 'hd1-file', 'filename':  hd_path[1] }

        result = self.vm.qmp('blockdev-add', conv_keys = False, **hd0_opts)
        self.assert_qmp(result, 'return', {})
        result = self.vm.qmp('blockdev-add', conv_keys = False, **hd1_opts)
        self.assert_qmp(result, 'return', {})

        # Add a raw format layer that uses hd0-file as its protocol layer
        opts = {'driver': 'raw', 'node-name': 'hd', 'file': 'hd0-file'}

        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Fill the image with data
        self.run_qemu_io("hd", "read  -P 0 0 10k")
        self.run_qemu_io("hd", "write -P 0xa0 0 10k")

        # Replace hd0-file with hd1-file and fill it with (different) data
        self.reopen(opts, {'file': 'hd1-file'})
        self.run_qemu_io("hd", "read  -P 0 0 10k")
        self.run_qemu_io("hd", "write -P 0xa1 0 10k")

        # Use hd0-file again and check that it contains the expected data
        self.reopen(opts, {'file': 'hd0-file'})
        self.run_qemu_io("hd", "read  -P 0xa0 0 10k")

        # And finally do the same with hd1-file
        self.reopen(opts, {'file': 'hd1-file'})
        self.run_qemu_io("hd", "read  -P 0xa1 0 10k")

    # Insert (and remove) a throttle filter
    def test_insert_throttle_filter(self):
        # Add an image to the VM
        hd0_opts = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **hd0_opts)
        self.assert_qmp(result, 'return', {})

        # Create a throttle-group object
        opts = { 'qom-type': 'throttle-group', 'id': 'group0',
                 'limits': { 'iops-total': 1000 } }
        result = self.vm.qmp('object-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Add a throttle filter with the group that we just created.
        # The filter is not used by anyone yet
        opts = { 'driver': 'throttle', 'node-name': 'throttle0',
                 'throttle-group': 'group0', 'file': 'hd0-file' }
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Insert the throttle filter between hd0 and hd0-file
        self.reopen(hd0_opts, {'file': 'throttle0'})

        # Remove the throttle filter from hd0
        self.reopen(hd0_opts, {'file': 'hd0-file'})

    # Insert (and remove) a compress filter
    def test_insert_compress_filter(self):
        # Add an image to the VM: hd (raw) -> hd0 (qcow2) -> hd0-file (file)
        opts = {'driver': 'raw', 'node-name': 'hd', 'file': hd_opts(0)}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Add a 'compress' filter
        filter_opts = {'driver': 'compress',
                       'node-name': 'compress0',
                       'file': 'hd0'}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **filter_opts)
        self.assert_qmp(result, 'return', {})

        # Unmap the beginning of the image (we cannot write compressed
        # data to an allocated cluster)
        self.run_qemu_io("hd", "write -z -u 0 128k")

        # Write data to the first cluster
        self.run_qemu_io("hd", "write -P 0xa0 0 64k")

        # Insert the filter then write to the second cluster
        # hd -> compress0 -> hd0 -> hd0-file
        self.reopen(opts, {'file': 'compress0'})
        self.run_qemu_io("hd", "write -P 0xa1 64k 64k")

        # Remove the filter then write to the third cluster
        # hd -> hd0 -> hd0-file
        self.reopen(opts, {'file': 'hd0'})
        self.run_qemu_io("hd", "write -P 0xa2 128k 64k")

        # Verify the data that we just wrote
        self.run_qemu_io("hd", "read -P 0xa0    0 64k")
        self.run_qemu_io("hd", "read -P 0xa1  64k 64k")
        self.run_qemu_io("hd", "read -P 0xa2 128k 64k")

        self.vm.shutdown()

        # Check the first byte of the first three L2 entries and verify that
        # the second one is compressed (0x40) while the others are not (0x80)
        iotests.qemu_io_log('-f', 'raw', '-c', 'read -P 0x80 0x40000 1',
                                         '-c', 'read -P 0x40 0x40008 1',
                                         '-c', 'read -P 0x80 0x40010 1', hd_path[0])

    # Swap the disk images of two active block devices
    def test_swap_files(self):
        # Add hd0 and hd2 (none of them with backing files)
        opts0 = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts0)
        self.assert_qmp(result, 'return', {})

        opts2 = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts2)
        self.assert_qmp(result, 'return', {})

        # Write different data to both block devices
        self.run_qemu_io("hd0", "write -P 0xa0 0 1k")
        self.run_qemu_io("hd2", "write -P 0xa2 0 1k")

        # Check that the data reads correctly
        self.run_qemu_io("hd0", "read  -P 0xa0 0 1k")
        self.run_qemu_io("hd2", "read  -P 0xa2 0 1k")

        # It's not possible to make a block device use an image that
        # is already being used by the other device.
        self.reopen(opts0, {'file': 'hd2-file'},
                    "Permission conflict on node 'hd2-file': permissions "
                    "'write, resize' are both required by node 'hd2' (uses "
                    "node 'hd2-file' as 'file' child) and unshared by node "
                    "'hd0' (uses node 'hd2-file' as 'file' child).")
        self.reopen(opts2, {'file': 'hd0-file'},
                    "Permission conflict on node 'hd0-file': permissions "
                    "'write, resize' are both required by node 'hd0' (uses "
                    "node 'hd0-file' as 'file' child) and unshared by node "
                    "'hd2' (uses node 'hd0-file' as 'file' child).")

        # But we can swap the images if we reopen both devices at the
        # same time
        opts0['file'] = 'hd2-file'
        opts2['file'] = 'hd0-file'
        self.reopenMultiple([opts0, opts2])
        self.run_qemu_io("hd0", "read  -P 0xa2 0 1k")
        self.run_qemu_io("hd2", "read  -P 0xa0 0 1k")

        # And we can of course come back to the original state
        opts0['file'] = 'hd0-file'
        opts2['file'] = 'hd2-file'
        self.reopenMultiple([opts0, opts2])
        self.run_qemu_io("hd0", "read  -P 0xa0 0 1k")
        self.run_qemu_io("hd2", "read  -P 0xa2 0 1k")

    # Misc reopen tests with different block drivers
    @iotests.skip_if_unsupported(['quorum', 'throttle'])
    def test_misc_drivers(self):
        ####################
        ###### quorum ######
        ####################
        for i in range(3):
            opts = hd_opts(i)
            # Open all three images without backing file
            opts['backing'] = None
            result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
            self.assert_qmp(result, 'return', {})

        opts = {'driver': 'quorum',
                'node-name': 'quorum0',
                'children': ['hd0', 'hd1', 'hd2'],
                'vote-threshold': 2}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Quorum doesn't currently allow reopening. TODO: implement this
        self.reopen(opts, {}, "Block format 'quorum' used by node 'quorum0'" +
                    " does not support reopening files")

        # You can't make quorum0 a backing file of hd0:
        # hd0 is already a child of quorum0.
        self.reopen(hd_opts(0), {'backing': 'quorum0'},
                    "Making 'quorum0' a backing child of 'hd0' would create a cycle")

        # Delete quorum0
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'quorum0')
        self.assert_qmp(result, 'return', {})

        # Delete hd0, hd1 and hd2
        for i in range(3):
            result = self.vm.qmp('blockdev-del', conv_keys = True,
                                 node_name = 'hd%d' % i)
            self.assert_qmp(result, 'return', {})

        ######################
        ###### blkdebug ######
        ######################
        opts = {'driver': 'blkdebug',
                'node-name': 'bd',
                'config': '/dev/null',
                'image': hd_opts(0)}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # blkdebug allows reopening if we keep the same options
        self.reopen(opts)

        # but it currently does not allow changes
        self.reopen(opts, {'image': 'hd1'}, "Cannot change the option 'image'")
        self.reopen(opts, {'align': 33554432}, "Cannot change the option 'align'")
        self.reopen(opts, {'config': '/non/existent'}, "Cannot change the option 'config'")
        del opts['config']
        self.reopen(opts, {}, "Option 'config' cannot be reset to its default value")

        # Delete the blkdebug node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'bd')
        self.assert_qmp(result, 'return', {})

        ##################
        ###### null ######
        ##################
        opts = {'driver': 'null-co', 'node-name': 'root', 'size': 1024}

        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # 1 << 30 is the default value, but we cannot change it explicitly
        self.reopen(opts, {'size': (1 << 30)}, "Cannot change the option 'size'")

        # We cannot change 'size' back to its default value either
        del opts['size']
        self.reopen(opts, {}, "Option 'size' cannot be reset to its default value")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'root')
        self.assert_qmp(result, 'return', {})

        ##################
        ###### file ######
        ##################
        opts = hd_opts(0)
        opts['file']['locking'] = 'on'
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # 'locking' cannot be changed
        del opts['file']['locking']
        self.reopen(opts, {'file.locking': 'on'})
        self.reopen(opts, {'file.locking': 'off'}, "Cannot change the option 'locking'")
        self.reopen(opts, {}, "Option 'locking' cannot be reset to its default value")

        # Trying to reopen the 'file' node directly does not make a difference
        opts = opts['file']
        self.reopen(opts, {'locking': 'on'})
        self.reopen(opts, {'locking': 'off'}, "Cannot change the option 'locking'")
        self.reopen(opts, {}, "Option 'locking' cannot be reset to its default value")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

        ######################
        ###### throttle ######
        ######################
        opts = { 'qom-type': 'throttle-group', 'id': 'group0',
                 'limits': { 'iops-total': 1000 } }
        result = self.vm.qmp('object-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        opts = { 'qom-type': 'throttle-group', 'id': 'group1',
                 'limits': { 'iops-total': 2000 } }
        result = self.vm.qmp('object-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Add a throttle filter with group = group0
        opts = { 'driver': 'throttle', 'node-name': 'throttle0',
                 'throttle-group': 'group0', 'file': hd_opts(0) }
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # We can reopen it if we keep the same options
        self.reopen(opts)

        # We can also reopen if 'file' is a reference to the child
        self.reopen(opts, {'file': 'hd0'})

        # This is illegal
        self.reopen(opts, {'throttle-group': 'notfound'}, "Throttle group 'notfound' does not exist")

        # But it's possible to change the group to group1
        self.reopen(opts, {'throttle-group': 'group1'})

        # Now group1 is in use, it cannot be deleted
        result = self.vm.qmp('object-del', id = 'group1')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "object 'group1' is in use, can not be deleted")

        # Default options, this switches the group back to group0
        self.reopen(opts)

        # So now we cannot delete group0
        result = self.vm.qmp('object-del', id = 'group0')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "object 'group0' is in use, can not be deleted")

        # But group1 is free this time, and it can be deleted
        result = self.vm.qmp('object-del', id = 'group1')
        self.assert_qmp(result, 'return', {})

        # Let's delete the filter node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'throttle0')
        self.assert_qmp(result, 'return', {})

        # And we can finally get rid of group0
        result = self.vm.qmp('object-del', id = 'group0')
        self.assert_qmp(result, 'return', {})

    # If an image has a backing file then the 'backing' option must be
    # passed on reopen. We don't allow leaving the option out in this
    # case because it's unclear what the correct semantics would be.
    def test_missing_backing_options_1(self):
        # hd2
        opts = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd0
        opts = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd0 has no backing file: we can omit the 'backing' option
        self.reopen(opts)

        # hd2 <- hd0
        self.reopen(opts, {'backing': 'hd2'})

        # hd0 has a backing file: we must set the 'backing' option
        self.reopen(opts, {}, "backing is missing for 'hd0'")

        # hd2 can't be removed because it's the backing file of hd0
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd2')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "Node 'hd2' is busy: node is used as backing hd of 'hd0'")

        # Detach hd2 from hd0.
        self.reopen(opts, {'backing': None})

        # Without a backing file, we can omit 'backing' again
        self.reopen(opts)

        # Remove both hd0 and hd2
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd2')
        self.assert_qmp(result, 'return', {})

    # If an image has default backing file (as part of its metadata)
    # then the 'backing' option must be passed on reopen. We don't
    # allow leaving the option out in this case because it's unclear
    # what the correct semantics would be.
    def test_missing_backing_options_2(self):
        # hd0 <- hd1
        # (hd0 is hd1's default backing file)
        opts = hd_opts(1)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd1 has a backing file: we can't omit the 'backing' option
        self.reopen(opts, {}, "backing is missing for 'hd1'")

        # Let's detach the backing file
        self.reopen(opts, {'backing': None})

        # No backing file attached to hd1 now, but we still can't omit the 'backing' option
        self.reopen(opts, {}, "backing is missing for 'hd1'")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd1')
        self.assert_qmp(result, 'return', {})

    # Test that making 'backing' a reference to an existing child
    # keeps its current options
    def test_backing_reference(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        # Enable 'detect-zeroes' on all three nodes
        opts['detect-zeroes'] = 'on'
        opts['backing']['detect-zeroes'] = 'on'
        opts['backing']['backing']['detect-zeroes'] = 'on'
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Reopen the chain passing the minimum amount of required options.
        # By making 'backing' a reference to hd1 (instead of a sub-dict)
        # we tell QEMU to keep its current set of options.
        opts = {'driver': iotests.imgfmt,
                'node-name': 'hd0',
                'file': 'hd0-file',
                'backing': 'hd1' }
        self.reopen(opts)

        # This has reset 'detect-zeroes' on hd0, but not on hd1 and hd2.
        self.assert_qmp(self.get_node('hd0'), 'detect_zeroes', 'off')
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'on')
        self.assert_qmp(self.get_node('hd2'), 'detect_zeroes', 'on')

    # Test what happens if the graph changes due to other operations
    # such as block-stream
    def test_block_stream_1(self):
        # hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = None
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Stream hd1 into hd0 and wait until it's done
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0', device = 'hd0')
        self.assert_qmp(result, 'return', {})
        self.wait_until_completed(drive = 'stream0')

        # Now we have only hd0
        self.assertEqual(self.get_node('hd1'), None)

        # We have backing.* options but there's no backing file anymore
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # If we remove the 'backing' option then we can reopen hd0 just fine
        del opts['backing']
        self.reopen(opts)

        # We can also reopen hd0 if we set 'backing' to null
        self.reopen(opts, {'backing': None})

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # Another block_stream test
    def test_block_stream_2(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Stream hd1 into hd0 and wait until it's done
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0',
                             device = 'hd0', base_node = 'hd2')
        self.assert_qmp(result, 'return', {})
        self.wait_until_completed(drive = 'stream0')

        # The chain is hd2 <- hd0 now. hd1 is missing
        self.assertEqual(self.get_node('hd1'), None)

        # The backing options in the dict were meant for hd1, but we cannot
        # use them with hd2 because hd1 had a backing file while hd2 does not.
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # If we remove hd1's options from the dict then things work fine
        opts['backing'] = opts['backing']['backing']
        self.reopen(opts)

        # We can also reopen hd0 if we use a reference to the backing file
        self.reopen(opts, {'backing': 'hd2'})

        # But we cannot leave the option out
        del opts['backing']
        self.reopen(opts, {}, "backing is missing for 'hd0'")

        # Now we can delete hd0 (and hd2)
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})
        self.assertEqual(self.get_node('hd2'), None)

    # Reopen the chain during a block-stream job (from hd1 to hd0)
    def test_block_stream_3(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd2 <- hd0
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0',
                             device = 'hd0', base_node = 'hd2',
                             auto_finalize = False)
        self.assert_qmp(result, 'return', {})

        # We can remove hd2 while the stream job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts, {})

        # We can't remove hd1 while the stream job is ongoing
        opts['backing'] = None
        self.reopen(opts, {}, "Cannot change frozen 'backing' link from 'hd0' to 'hd1'")

        self.vm.run_job('stream0', auto_finalize = False, auto_dismiss = True)

    # Reopen the chain during a block-stream job (from hd2 to hd1)
    def test_block_stream_4(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd1 <- hd0
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0',
                             device = 'hd1', filter_node_name='cor',
                             auto_finalize = False)
        self.assert_qmp(result, 'return', {})

        # We can't reopen with the original options because there is a filter
        # inserted by stream job above hd1.
        self.reopen(opts, {},
                    "Cannot change the option 'backing.backing.file.node-name'")

        # We can't reopen hd1 to read-only, as block-stream requires it to be
        # read-write
        self.reopen(opts['backing'], {'read-only': True},
                    "Read-only block node 'hd1' cannot support read-write users")

        # We can't remove hd2 while the stream job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts['backing'], {'read-only': False},
                    "Cannot change frozen 'backing' link from 'hd1' to 'hd2'")

        # We can detach hd1 from hd0 because it doesn't affect the stream job
        opts['backing'] = None
        self.reopen(opts)

        self.vm.run_job('stream0', auto_finalize = False, auto_dismiss = True)

    # Reopen the chain during a block-commit job (from hd0 to hd2)
    def test_block_commit_1(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('block-commit', conv_keys = True, job_id = 'commit0',
                             device = 'hd0')
        self.assert_qmp(result, 'return', {})

        # We can't remove hd2 while the commit job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts, {}, "Cannot change frozen 'backing' link from 'hd1' to 'hd2'")

        # We can't remove hd1 while the commit job is ongoing
        opts['backing'] = None
        self.reopen(opts, {}, "Cannot change frozen 'backing' link from 'hd0' to 'hd1'")

        event = self.vm.event_wait(name='BLOCK_JOB_READY')
        self.assert_qmp(event, 'data/device', 'commit0')
        self.assert_qmp(event, 'data/type', 'commit')
        self.assert_qmp_absent(event, 'data/error')

        result = self.vm.qmp('block-job-complete', device='commit0')
        self.assert_qmp(result, 'return', {})

        self.wait_until_completed(drive = 'commit0')

    # Reopen the chain during a block-commit job (from hd1 to hd2)
    def test_block_commit_2(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('block-commit', conv_keys = True, job_id = 'commit0',
                             device = 'hd0', top_node = 'hd1',
                             auto_finalize = False)
        self.assert_qmp(result, 'return', {})

        # We can't remove hd2 while the commit job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # We can't remove hd1 while the commit job is ongoing
        opts['backing'] = None
        self.reopen(opts, {}, "Cannot replace implicit backing child of hd0")

        # hd2 <- hd0
        self.vm.run_job('commit0', auto_finalize = False, auto_dismiss = True)

        self.assert_qmp(self.get_node('hd0'), 'ro', False)
        self.assertEqual(self.get_node('hd1'), None)
        self.assert_qmp(self.get_node('hd2'), 'ro', True)

    def run_test_iothreads(self, iothread_a, iothread_b, errmsg = None,
                           opts_a = None, opts_b = None):
        opts = opts_a or hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        opts2 = opts_b or hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts2)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('object-add', qom_type='iothread', id='iothread0')
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('object-add', qom_type='iothread', id='iothread1')
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('device_add', driver='virtio-scsi', id='scsi0',
                             iothread=iothread_a)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('device_add', driver='virtio-scsi', id='scsi1',
                             iothread=iothread_b)
        self.assert_qmp(result, 'return', {})

        if iothread_a:
            result = self.vm.qmp('device_add', driver='scsi-hd', drive='hd0',
                                 share_rw=True, bus="scsi0.0")
            self.assert_qmp(result, 'return', {})

        if iothread_b:
            result = self.vm.qmp('device_add', driver='scsi-hd', drive='hd2',
                                 share_rw=True, bus="scsi1.0")
            self.assert_qmp(result, 'return', {})

        # Attaching the backing file may or may not work
        self.reopen(opts, {'backing': 'hd2'}, errmsg)

        # But removing the backing file should always work
        self.reopen(opts, {'backing': None})

        self.vm.shutdown()

    # We don't allow setting a backing file that uses a different AioContext if
    # neither of them can switch to the other AioContext
    def test_iothreads_error(self):
        self.run_test_iothreads('iothread0', 'iothread1',
                                "Cannot change iothread of active block backend")

    def test_iothreads_compatible_users(self):
        self.run_test_iothreads('iothread0', 'iothread0')

    def test_iothreads_switch_backing(self):
        self.run_test_iothreads('iothread0', '')

    def test_iothreads_switch_overlay(self):
        self.run_test_iothreads('', 'iothread0')

    def test_iothreads_with_throttling(self):
        # Create a throttle-group object
        opts = { 'qom-type': 'throttle-group', 'id': 'group0',
                 'limits': { 'iops-total': 1000 } }
        result = self.vm.qmp('object-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Options with a throttle filter between format and protocol
        opts = [
            {
                'driver': iotests.imgfmt,
                'node-name': f'hd{idx}',
                'file' : {
                    'node-name': f'hd{idx}-throttle',
                    'driver': 'throttle',
                    'throttle-group': 'group0',
                    'file': {
                        'driver': 'file',
                        'node-name': f'hd{idx}-file',
                        'filename': hd_path[idx],
                    },
                },
            }
            for idx in (0, 2)
        ]

        self.run_test_iothreads('iothread0', 'iothread0', None,
                                opts[0], opts[1])

if __name__ == '__main__':
    iotests.activate_logging()
    iotests.main(supported_fmts=["qcow2"],
                 supported_protocols=["file"])
