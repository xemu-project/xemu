#!/usr/bin/env bash
# group: rw blkdbg
#
# qcow2 error path testing
#
# Copyright (C) 2010 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# creator
owner=kwolf@redhat.com

seq=`basename $0`
echo "QA output created by $seq"

status=1	# failure is the default!

_cleanup()
{
	_cleanup_test_img
    rm "$TEST_DIR/blkdebug.conf"
    rm -f "$TEST_IMG.data_file"
}
trap "_cleanup; exit \$status" 0 1 2 3 15

# get standard environment, filters and checks
. ./common.rc
. ./common.filter
. ./common.pattern

# Currently only qcow2 supports rebasing
_supported_fmt qcow2
_supported_proto file fuse
_default_cache_mode writethrough
_supported_cache_modes writethrough none
# The refcount table tests expect a certain minimum width for refcount entries
# (so that the refcount table actually needs to grow); that minimum is 16 bits,
# being the default refcount entry width.
# 32 and 64 bits do not work either, however, due to different leaked cluster
# count on error.
# Thus, the only remaining option is refcount_bits=16.
#
# As for data_file, none of the refcount tests can work for it.
_unsupported_imgopts 'refcount_bits=\([^1]\|.\([^6]\|$\)\)' \
    data_file

echo "Errors while writing 128 kB"
echo

CLUSTER_SIZE=1024

BLKDBG_TEST_IMG="blkdebug:$TEST_DIR/blkdebug.conf:$TEST_IMG"

for event in \
    l1_update \
    \
    l2_load \
    l2_update \
    l2_alloc_write \
    \
    write_aio \
    \
    refblock_load \
    refblock_update_part \
    refblock_alloc \
    \
    cluster_alloc \

do

for errno in 5 28; do
for imm in off; do
for once in on off; do
for vmstate in "" "-b"; do

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "$event"
errno = "$errno"
immediately = "$imm"
once ="$once"
EOF

_make_test_img 1G

echo
echo "Event: $event; errno: $errno; imm: $imm; once: $once; write $vmstate"

# We want to catch a simple L2 update, not the allocation of the first L2 table
if [ "$event" == "l2_update" ]; then
    $QEMU_IO -c "write $vmstate 0 512" "$TEST_IMG" > /dev/null 2>&1
fi

$QEMU_IO -c "write $vmstate 0 128k " "$BLKDBG_TEST_IMG" | _filter_qemu_io

# l2_load is not called on allocation, so issue a second write
# Reads are another path to trigger l2_load, so do a read, too
if [ "$event" == "l2_load" ]; then
    $QEMU_IO -c "write $vmstate 0 128k " "$BLKDBG_TEST_IMG" | _filter_qemu_io
    $QEMU_IO -c "read $vmstate 0 128k " "$BLKDBG_TEST_IMG" | _filter_qemu_io
fi

_check_test_img_ignore_leaks 2>&1 | grep -v "refcount=1 reference=0"

done
done
done
done
done


echo
echo === Refcount table growth tests ===
echo
CLUSTER_SIZE=512


for event in \
    refblock_alloc_hookup \
    refblock_alloc_write \
    refblock_alloc_write_blocks \
    refblock_alloc_write_table \
    refblock_alloc_switch_table \

do

# This one takes a while, so let's test only one error code (ENOSPC should
# never be generated by qemu, so it's probably a good choice)
for errno in 28; do
for imm in off; do
for once in on off; do
for vmstate in "" "-b"; do

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "$event"
errno = "$errno"
immediately = "$imm"
once = "$once"
EOF

_make_test_img 1G

echo
echo "Event: $event; errno: $errno; imm: $imm; once: $once; write $vmstate"
$QEMU_IO -c "write $vmstate 0 64M" "$BLKDBG_TEST_IMG" | _filter_qemu_io

_check_test_img_ignore_leaks 2>&1 | grep -v "refcount=1 reference=0"

done
done
done
done
done

echo
echo === L1 growth tests ===
echo
CLUSTER_SIZE=1024


for event in \
    l1_grow_alloc_table \
    l1_grow_write_table \
    l1_grow_activate_table \

do

for errno in 5 28; do
for imm in off; do
for once in on off; do

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "$event"
errno = "$errno"
immediately = "$imm"
once = "$once"
EOF

_make_test_img 1G

echo
echo "Event: $event; errno: $errno; imm: $imm; once: $once"
$QEMU_IO -c "write -b 0 64k" "$BLKDBG_TEST_IMG" | _filter_qemu_io

_check_test_img_ignore_leaks 2>&1 | grep -v "refcount=1 reference=0"

done
done
done
done

echo
echo === Avoid cluster leaks after temporary failure ===
echo

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "write_aio"
errno = "5"
once = "on"
EOF

# After the failed first write, do a second write so that the updated refcount
# block is actually written back
_make_test_img 64M
$QEMU_IO -c "write 0 1M" -c "write 0 1M" "$BLKDBG_TEST_IMG" | _filter_qemu_io
_check_test_img

echo
echo === Avoid freeing preallocated zero clusters on failure ===
echo

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "write_aio"
errno = "5"
once = "on"
EOF

_make_test_img $CLUSTER_SIZE
# Create a preallocated zero cluster
$QEMU_IO -c "write 0 $CLUSTER_SIZE" -c "write -z 0 $CLUSTER_SIZE" "$TEST_IMG" \
    | _filter_qemu_io
# Try to overwrite it (prompting an I/O error from blkdebug), thus
# triggering the alloc abort code
$QEMU_IO -c "write 0 $CLUSTER_SIZE" "$BLKDBG_TEST_IMG" | _filter_qemu_io

_check_test_img

# success, all done
echo "*** done"
rm -f $seq.full
status=0
